/*
 * math.h
 *
 *  Created on: Apr 1, 2022
 *      Author: pudja
 */

#ifndef ARM_MATH_S16_H_
#define ARM_MATH_S16_H_

#include <stdint.h>

/**
 * @brief definition to read/write two 16 bit values.
 */
#if   defined ( __CC_ARM )
  #define __SIMD32_TYPE int32_t __packed
#elif defined ( __ARMCC_VERSION ) && ( __ARMCC_VERSION >= 6010050 )
  #define __SIMD32_TYPE int32_t
#elif defined ( __GNUC__ )
#define __SIMD32_TYPE int32_t
#elif defined ( __ICCARM__ )
  #define __SIMD32_TYPE int32_t __packed
#elif defined ( __TI_ARM__ )
  #define __SIMD32_TYPE int32_t
#elif defined ( __CSMC__ )
  #define __SIMD32_TYPE int32_t
#elif defined ( __TASKING__ )
  #define __SIMD32_TYPE __unaligned int32_t
#else
  #error Unknown compiler
#endif

#define __SIMD32(addr)        (*(__SIMD32_TYPE **) & (addr))
#define __SIMD32_CONST(addr)  ((__SIMD32_TYPE *)(addr))
#define _SIMD32_OFFSET(addr)  (*(__SIMD32_TYPE *)  (addr))

/**
 * @brief Error status returned by some functions in the library.
 */

typedef enum
{
  ARM_MATH_SUCCESS = 0, /**< No error */
  ARM_MATH_ARGUMENT_ERROR = -1, /**< One or more arguments are incorrect */
  ARM_MATH_LENGTH_ERROR = -2, /**< Length of data buffer is incorrect */
  ARM_MATH_SIZE_MISMATCH = -3, /**< Size of matrices is not compatible with the operation. */
  ARM_MATH_NANINF = -4, /**< Not-a-number (NaN) or infinity is generated */
  ARM_MATH_SINGULAR = -5, /**< Generated by matrix inversion if the input matrix is singular and cannot be inverted. */
  ARM_MATH_TEST_FAILURE = -6 /**< Test Failed  */
} arm_status;

/**
 * @brief Instance structure for the S16 matrix structure.
 */
typedef struct
{
  uint16_t numRows; /**< number of rows of the matrix.     */
  uint16_t numCols; /**< number of columns of the matrix.  */
  int16_t *pData; /**< points to the data of the matrix. */
} arm_matrix_instance_s16;

/* Public function prototypes */
void arm_fill_s16(int16_t value, int16_t *pDst, uint32_t blockSize);
void arm_copy_s16(int16_t *pSrc, int16_t *pDst, uint32_t blockSize);
void arm_add_s16(int16_t *pSrcA, int16_t *pSrcB, int16_t *pDst, uint32_t blockSize);
void arm_sub_s16(int16_t *pSrcA, int16_t *pSrcB, int16_t *pDst, uint32_t blockSize);
void arm_mean_s16(int16_t *pSrc, uint32_t blockSize, int16_t *pResult);
void arm_shift_s16(int16_t *pSrc, int8_t shiftBits, int16_t *pDst, uint32_t blockSize);
void arm_abs_s16(int16_t *pSrc, int16_t *pDst, uint32_t blockSize);
void arm_mat_init_s16(arm_matrix_instance_s16 *S, uint16_t nRows, uint16_t nColumns, int16_t *pData);
arm_status arm_mat_trans_s16(const arm_matrix_instance_s16 *pSrc, arm_matrix_instance_s16 *pDst);

#endif /* ARM_MATH_S16_H_ */
